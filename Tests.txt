









        classpath 'org.hibernate.build.gradle:gradle-upload-auth-plugin:1.0.2'
    }




            if (project.name != "test-testng") {
                testCompile project(':test-testng')
            }
            testCompile('org.testng:testng:5.14.6') { transitive = false }
            testCompile('com.beust:jcommander:1.5') { transitive = false }
            testCompile('org.beanshell:bsh:2.0b4') { transitive = false }
            testCompile('org.hamcrest:hamcrest-core:1.3.RC2') { transitive = false }
            testCompile('org.hamcrest:hamcrest-library:1.3.RC2') { transitive = false }
        }
    


		classpath 'io.spring.gradle:docbook-reference-plugin:0.3.1'
		classpath 'org.asciidoctor:asciidoctor-gradle-plugin:1.5.0'
		classpath 'me.champeau.gradle:gradle-javadoc-hotfix-plugin:0.1'
		classpath 'io.spring.gradle:dependency-management-plugin:0.6.1.RELEASE'
		classpath 'io.spring.gradle:spring-io-plugin:0.0.6.RELEASE'
	}


            provided {
                // todo : need to make sure these are non-exported
                description = 'Non-exported compile-time dependencies.'
            }
            deployerJars {
                description = 'Jars needed for doing deployment to JBoss Nexus repo'
            }
        }

        // appropriately inject the common dependencies into each sub-project
        dependencies {
            compile( libraries.slf4j_api )
            testCompile( libraries.junit )
            testRuntime( libraries.slf4j_simple )
            testRuntime( libraries.jcl_slf4j )
            testRuntime( libraries.jcl_api )
            testRuntime( libraries.jcl )
            testRuntime( libraries.javassist )
            testRuntime( libraries.h2 )
            deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-6"
        }

        sourceSets {
            main {
                compileClasspath += configurations.provided
            }
        }

        manifest.mainAttributes(
                provider: 'gradle',
                'Implementation-Url': 'http://hibernate.org',
                'Implementation-Version': version,
                'Implementation-Vendor': 'Hibernate.org',
                'Implementation-Vendor-Id': 'org.hibernate'
        )

        test {
            systemProperties['hibernate.test.validatefailureexpected'] = true
            maxHeapSize = "1024m"
        }

        processTestResources.doLast( {
            copy {
                from( sourceSets.test.java.srcDirs ) {
                    include '**/*.properties'
                    include '**/*.xml'
                }
                into sourceSets.test.classesDir
            }
        } )

        assemble.doLast( { install } )
        uploadArchives.dependsOn install

        targetCompatibility = "1.6"
        sourceCompatibility = "1.6"

        ideaModule {
            // treat our "provided" configuration dependencies as "Compile" scope dependencies in IntelliJ
            scopes.COMPILE.plus.add( configurations.provided )
            // Use explicitly separate compilation output directories for Gradle and IntelliJ
            File baseDirectory = new File( subProject.buildDir, "idea/classes" )
            outputDir = new File( baseDirectory, "main" )
            testOutputDir = new File( baseDirectory, "test" )
            whenConfigured { module ->
                module.dependencies*.exported = true
            }
        }
		eclipseClasspath {
			plusConfigurations.add( configurations.provided )
		}

        // elements used to customize the generated POM used during upload
        def pomConfig = {
            url 'http://hibernate.org'
            organization {
                name 'Hibernate.org'
                url 'http://hibernate.org'
            }
            issueManagement {
                system 'jira'
                url 'http://opensource.atlassian.com/projects/hibernate/browse/HHH'
            }
            scm {
                url "http://github.com/hibernate/hibernate-core"
                connection "scm:git:http://github.com/hibernate/hibernate-core.git"
                developerConnection "scm:git:git@github.com:hibernate/hibernate-core.git"
            }
            licenses {
                license {
                    name 'GNU Lesser General Public License'
                    url 'http://www.gnu.org/licenses/lgpl-2.1.html'
                    comments 'See discussion at http://hibernate.org/356.html for more details.'
                    distribution 'repo'
                }
            }
            developers {
            }
        }

        configure(install.repositories.mavenInstaller) {
            pom.project pomConfig
        }

        uploadArchives {
            repositories.mavenDeployer {
                name = 'jbossDeployer'
                configuration = configurations.deployerJars
                pom.project pomConfig
                repository(url: "https://repository.jboss.org/nexus/service/local/staging/deploy/maven2/")
                snapshotRepository(url: "https://repository.jboss.org/nexus/content/repositories/snapshots")
            }
        }

        task sourcesJar(type: Jar, dependsOn: compileJava) {
            from sourceSets.main.allSource
            classifier = 'sources'
        }

        artifacts {
            archives sourcesJar
        }

        uploadArchives.dependsOn sourcesJar
    

        classpath "commons-io:commons-io:1.4"
    }



        classpath 'com.android.tools.build:gradle:1.5.0'
    }


		classpath("io.spring.gradle:propdeps-plugin:0.0.8")
		classpath("io.spring.gradle:docbook-reference-plugin:0.3.1")
		classpath("org.asciidoctor:asciidoctorj-pdf:1.5.0-alpha.16")
		classpath("org.asciidoctor:asciidoctorj-epub3:1.5.0-alpha.7")
	}


    classpath 'org.linkedin:org.linkedin.gradle-plugins:1.3.1'
  }



        classpath 'com.android.tools.build:gradle:1.0.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }


		classpath 'kaizen:kaizen:0.2.2'
	}


        compile project(':jmd-core')
    }

    jar {
        manifest {
            attributes 'Implementation-Title': 'net.contra.jmd',
                    'Implementation-Version': version,
                    'Main-Class': 'net.contra.jmd.Deobfuscator'
        }

        from {
            configurations.compile.collect {
                it.isDirectory() ? it : zipTree(it)
            }
        }
    }



        classpath 'com.android.tools.build:gradle:2.2.2'
    }





		classpath 'org.springframework.build.gradle:docbook-reference-plugin:0.1.5'
	}





        classpath 'org.hibernate.build.gradle:gradle-upload-auth-plugin:1.0.0'
    }


            provided {
                // todo : need to make sure these are non-exported
                description = 'Non-exported compile-time dependencies.'
            }
            deployerJars {
                description = 'Jars needed for doing deployment to JBoss Nexus repo'
            }
        }

        // appropriately inject the common dependencies into each sub-project
        dependencies {
            compile( libraries.slf4j_api )
            testCompile( libraries.junit )
            testRuntime( libraries.slf4j_simple )
            testRuntime( libraries.jcl_slf4j )
            testRuntime( libraries.jcl_api )
            testRuntime( libraries.jcl )
            testRuntime( libraries.javassist )
            testRuntime( libraries.h2 )
            deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-6"
        }

        sourceSets {
            main {
                compileClasspath += configurations.provided
            }
        }

        manifest.mainAttributes(
                provider: 'gradle',
                'Implementation-Url': 'http://hibernate.org',
                'Implementation-Version': version,
                'Implementation-Vendor': 'Hibernate.org',
                'Implementation-Vendor-Id': 'org.hibernate'
        )

        test {
            systemProperties['hibernate.test.validatefailureexpected'] = true
            maxHeapSize = "1024m"
        }

        processTestResources.doLast( {
            copy {
                from( sourceSets.test.java.srcDirs ) {
                    include '**/*.properties'
                    include '**/*.xml'
                }
                into sourceSets.test.classesDir
            }
        } )

        assemble.doLast( { install } )
        uploadArchives.dependsOn install

        targetCompatibility = "1.6"
        sourceCompatibility = "1.6"

        ideaModule {
            // treat our "provided" configuration dependencies as "Compile" scope dependencies in IntelliJ
            scopes.COMPILE.plus.add( configurations.provided )
            // Use explicitly separate compilation output directories for Gradle and IntelliJ
            File baseDirectory = new File( subProject.buildDir, "idea/classes" )
            outputDir = new File( baseDirectory, "main" )
            testOutputDir = new File( baseDirectory, "test" )
            whenConfigured { module ->
                module.dependencies*.exported = true
            }
        }
		eclipseClasspath {
			plusConfigurations.add( configurations.provided )
		}

        // elements used to customize the generated POM used during upload
        def pomConfig = {
            url 'http://hibernate.org'
            organization {
                name 'Hibernate.org'
                url 'http://hibernate.org'
            }
            issueManagement {
                system 'jira'
                url 'http://opensource.atlassian.com/projects/hibernate/browse/HHH'
            }
            scm {
                url "http://github.com/hibernate/hibernate-core"
                connection "scm:git:http://github.com/hibernate/hibernate-core.git"
                developerConnection "scm:git:git@github.com:hibernate/hibernate-core.git"
            }
            licenses {
                license {
                    name 'GNU Lesser General Public License'
                    url 'http://www.gnu.org/licenses/lgpl-2.1.html'
                    comments 'See discussion at http://hibernate.org/356.html for more details.'
                    distribution 'repo'
                }
            }
            developers {
            }
        }

        subProject.basePomConfig = pomConfig

        configure(install.repositories.mavenInstaller) {
            pom.project pomConfig
        }

        uploadArchives {
            repositories.mavenDeployer {
                name = 'jbossDeployer'
                configuration = configurations.deployerJars
                pom.project pomConfig
                repository(id: "jboss-releases-repository", url: "https://repository.jboss.org/nexus/service/local/staging/deploy/maven2/")
                snapshotRepository(id: "jboss-snapshots-repository", url: "https://repository.jboss.org/nexus/content/repositories/snapshots")
            }
        }

        task sourcesJar(type: Jar, dependsOn: compileJava) {
            from sourceSets.main.allSource
            classifier = 'sources'
        }

        artifacts {
            archives sourcesJar
        }

        uploadArchives.dependsOn sourcesJar
    



        classpath 'com.android.tools.build:gradle:2.1.3'
    }


        classpath 'com.android.tools.build:gradle:2.1.3'
    }


        classpath 'com.android.tools.build:gradle:2.1.3'
    }


        classpath 'com.android.tools.build:gradle:2.2.2'
    }


        classpath 'com.android.tools.build:gradle:3.0.1'
    }


        classpath 'org.springframework.build.gradle:propdeps-plugin:0.0.5'
    }



        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }



		classpath 'org.hibernate.build.gradle:gradle-maven-publish-auth:2.0.1'
		classpath 'org.hibernate.build.gradle:hibernate-matrix-testing:2.0.0-SNAPSHOT'
		classpath 'org.hibernate.build.gradle:version-injection-plugin:1.0.0'
		classpath 'org.hibernate.build.gradle:gradle-xjc-plugin:1.0.2.Final'
		classpath 'com.github.lburgazzoli:lb-karaf-features-gen:1.0.0-SNAPSHOT'
	}




        classpath 'com.android.tools.build:gradle:2.2.3'
    }





        classpath "commons-io:commons-io:1.4"
    }











        classpath 'org.gradle.api.plugins:gradle-cargo-plugin:1.5'
    }


        classpath "commons-io:commons-io:1.4"
    }



        classpath group: 'org.gradlefx', name: 'gradlefx', version: '0.8.1'
        classpath 'com.github.townsfolk:gradle-release:1.2'
    }


        classpath "commons-io:commons-io:2.1"
        //classpath "com.goldin.plugins:gradle:0.1-RC3" // http://evgeny-goldin.com/wiki/Gradle-duplicates-plugin
    }






        classpath "commons-io:commons-io:1.4"
    }



        classpath 'com.android.tools.build:gradle:3.0.1'
    }






        classpath "commons-io:commons-io:1.4"
    }




 classpath("org.springframework.boot:spring-boot-gradle-plugin:1.2.2.RELEASE") }


		classpath "org.gradle.plugins:gradle-idea-plugin:0.2"
	}


            if (project.name != "test-testng") {
                testCompile project(':test-testng')
            }
            testCompile('org.testng:testng:5.14.6') { transitive = false }
            testCompile('com.beust:jcommander:1.5') { transitive = false }
            testCompile('org.beanshell:bsh:2.0b4') { transitive = false }
            testCompile('org.hamcrest:hamcrest-core:1.3.RC2') { transitive = false }
            testCompile('org.hamcrest:hamcrest-library:1.3.RC2') { transitive = false }
        }
    

        classpath "commons-io:commons-io:1.4"
    }


        testCompile 'org.testng:testng:6.8'
    }

    test {
	    useTestNG()
    }


		if(isStandardGroovyMavenProject) {
	       	groovy group: 'org.codehaus.groovy', name: 'groovy-all', version: '1.7.4'

            testCompile 'junit:junit:4.8.1'
            testCompile spockDependency
        }
        
        if (project.name == "grails-datastore-gorm-tck") {
          compile spockDependency
        }
    }

    if (isGormDatasource) {
      dependencies {
        testCompile project(":grails-datastore-gorm-tck")
      }
      
      // We need to test against the TCK. Gradle cannot find/run tests from jars
      // without a lot of plumbing, so here we copy the class files from the TCK
      // project into this project's test classes dir so Gradle can find the test
      // classes and run them. See grails.gorm.tests.GormDatastoreSpec for on the TCK.
      
      // helper, used below.
      def toBaseClassRelativePathWithoutExtension = { String base, String classFile ->
        if (classFile.startsWith(base)) {
          def sansClass = classFile[0 .. classFile.size() - ".class".size() - 1]
          def dollarIndex = sansClass.indexOf('$')
          def baseClass = dollarIndex > 0 ? sansClass[0..dollarIndex - 1] : sansClass
          def relative = baseClass - base - '/'
          relative
        } else {
          null
        }
      }

      test.doFirst {
        def tckClassesDir = project(":grails-datastore-gorm-tck").sourceSets.main.classesDir
        def thisProjectsTests =  // surely there is a less hardcoded way to do this
        copy {
          from tckClassesDir
          into sourceSets.test.classesDir
          include "**/*.class"
          exclude { details ->
            // Do not copy across any TCK class (or nested classes of that class)
            // If there is a corresponding source file in the particular modules 
            // test source tree. Allows a module to override a test/helper.
            
            def candidatePath = details.file.absolutePath
            def relativePath = toBaseClassRelativePathWithoutExtension(tckClassesDir.absolutePath, candidatePath)

            if (relativePath == null) {
              throw new IllegalStateException("$candidatePath does not appear to be in the TCK")
            }
            
            project.file("src/test/groovy/${relativePath}.groovy").exists()
          }
        }
      }
    }

    if(project.name.startsWith("grails-")) {
      group = "org.grails"
      archivesBaseName = "grails-datastore"
    }
    else {
      group = "org.springframework"
      archivesBaseName = 'spring-datastore'
    }

    if(isStandardGroovyMavenProject) {
      configure(install.repositories.mavenInstaller) {
          pom.whenConfigured { pom ->
            def dependency = pom.dependencies.find { dep -> dep.artifactId == 'slf4j-simple' }
            dependency?.optional = true
          }
          pom.project {
            licenses {
                license {
                    name 'The Apache Software License, Version 2.0'
                    url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    distribution 'http://github.com/grails/inconsequential'
                }
            }
          }
      }

      uploadArchives {
          description = "Does a maven deploy of archives artifacts"
          def isDav = System.getProperty("deploy.protocol") == 'dav'
          def protocol = isDav ? 'dav:' : ''
//          def releaseRepositoryUrl = "https://dav.codehaus.org/repository/grails/"
          def milestoneRepositoryUrl = isSpringProject ? 's3://maven.springframework.org/milestone' :
                                                         "${protocol}https://dav.codehaus.org/repository/grails/"
          def snapshotRepositoryUrl = isSpringProject ? 's3://maven.springframework.org/snapshot' :
                                                        "${protocol}https://dav.codehaus.org/snapshots.repository/grails/"

          // add a configuration with a classpath that includes our s3 maven deployer
          configurations { deployerJars }
          dependencies {

            deployerJars "org.springframework.build.aws:org.springframework.build.aws.maven:3.0.0.RELEASE"

            // NOTE!!!!!: Maven deployment over webdav is broken due to SHA1 checksum issues. To deploy
            // you first need to run ./gradlew -Ddeploy.protocol=dav uploadArchives
            // and then ./gradlew uploadArchives a second time to get a valid deployment

            if(isDav) {
              deployerJars "org.apache.maven.wagon:wagon-webdav-jackrabbit:1.0-beta-6"
            }
            else {
              deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-6"
            }



          }

          repositories.mavenDeployer {
              switch (releaseType) {
                  case 'RELEASE':
                    // TODO: Will need to update this when doing a non-snapshot/milestone release
//                      repository(url: releaseRepositoryUrl)
//                      description += releaseRepositoryUrl
                      break;

                  case ~/M[0-9]+/:
                      description += milestoneRepositoryUrl
                      // fall through and pick up config below

                  case 'BUILD-SNAPSHOT':
                      description += snapshotRepositoryUrl
                      def credentials
                      if(isSpringProject) {
                        credentials = [userName: project.properties.s3AccessKey,
                                       passphrase: project.properties.s3SecretAccessKey]
                      }
                      else {
                        credentials = [userName: project.properties['codehaus.username'],
                                       password: project.properties['codehaus.password']]
                      }
                      configuration = configurations.deployerJars
                      repository(url: milestoneRepositoryUrl) {
                          authentication(credentials)
                      }
                      snapshotRepository(url: snapshotRepositoryUrl) {
                          authentication(credentials)
                      }
                    break;
              }

              pom.project {
                  licenses {
                      license {
                          name 'The Apache Software License, Version 2.0'
                          url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                          distribution 'repo'
                      }
                  }
              }
          }
      }

    }


            provided {
                // todo : need to make sure these are non-exported
                description = 'Non-exported compile-time dependencies.'
            }
            deployerJars {
                description = 'Jars needed for doing deployment to JBoss Nexus repo'
            }
        }

        // appropriately inject the common dependencies into each sub-project
        dependencies {
            compile( libraries.slf4j_api )
            testCompile( libraries.junit )
            testRuntime( libraries.slf4j_simple )
            testRuntime( libraries.jcl_slf4j )
            testRuntime( libraries.jcl_api )
            testRuntime( libraries.jcl )
            testRuntime( libraries.javassist )
            testRuntime( libraries.h2 )
            deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-6"
        }

        sourceSets {
            main {
                compileClasspath += configurations.provided
            }
        }

        manifest.mainAttributes(
                provider: 'gradle',
                'Implementation-Url': 'http://hibernate.org',
                'Implementation-Version': version,
                'Implementation-Vendor': 'Hibernate.org',
                'Implementation-Vendor-Id': 'org.hibernate'
        )

        test {
            systemProperties['hibernate.test.validatefailureexpected'] = true
            maxHeapSize = "1024m"
        }

        processTestResources.doLast( {
            copy {
                from( sourceSets.test.java.srcDirs ) {
                    include '**/*.properties'
                    include '**/*.xml'
                }
                into sourceSets.test.classesDir
            }
        } )

        assemble.doLast( { install } )
        uploadArchives.dependsOn install

        targetCompatibility = "1.6"
        sourceCompatibility = "1.6"

        ideaModule {
            // treat our "provided" configuration dependencies as "Compile" scope dependencies in IntelliJ
            scopes.COMPILE.plus.add( configurations.provided )
            // Use explicitly separate compilation output directories for Gradle and IntelliJ
            File baseDirectory = new File( subProject.buildDir, "idea/classes" )
            outputDir = new File( baseDirectory, "main" )
            testOutputDir = new File( baseDirectory, "test" )
            whenConfigured { module ->
                module.dependencies*.exported = true
            }
        }
		eclipseClasspath {
			plusConfigurations.add( configurations.provided )
		}

        // elements used to customize the generated POM used during upload
        def pomConfig = {
            url 'http://hibernate.org'
            organization {
                name 'Hibernate.org'
                url 'http://hibernate.org'
            }
            issueManagement {
                system 'jira'
                url 'http://opensource.atlassian.com/projects/hibernate/browse/HHH'
            }
            scm {
                url "http://github.com/hibernate/hibernate-core"
                connection "scm:git:http://github.com/hibernate/hibernate-core.git"
                developerConnection "scm:git:git@github.com:hibernate/hibernate-core.git"
            }
            licenses {
                license {
                    name 'GNU Lesser General Public License'
                    url 'http://www.gnu.org/licenses/lgpl-2.1.html'
                    comments 'See discussion at http://hibernate.org/356.html for more details.'
                    distribution 'repo'
                }
            }
            developers {
            }
        }

        configure(install.repositories.mavenInstaller) {
            pom.project pomConfig
        }

        uploadArchives {
            repositories.mavenDeployer {
                name = 'jbossDeployer'
                configuration = configurations.deployerJars
                pom.project pomConfig
                repository(url: "https://repository.jboss.org/nexus/service/local/staging/deploy/maven2/")
                snapshotRepository(url: "https://repository.jboss.org/nexus/content/repositories/snapshots")
            }
        }

        task sourcesJar(type: Jar, dependsOn: compileJava) {
            from sourceSets.main.allSource
            classifier = 'sources'
        }

        artifacts {
            archives sourcesJar
        }

        uploadArchives.dependsOn sourcesJar
    

            provided {
                // todo : need to make sure these are non-exported
                description = 'Non-exported compile-time dependencies.'
            }
            deployerJars {
                description = 'Jars needed for doing deployment to JBoss Nexus repo'
            }
        }

        // appropriately inject the common dependencies into each sub-project
        dependencies {
            compile( libraries.slf4j_api )
            testCompile( libraries.junit )
            testRuntime( libraries.slf4j_simple )
            testRuntime( libraries.jcl_slf4j )
            testRuntime( libraries.jcl_api )
            testRuntime( libraries.jcl )
            testRuntime( libraries.javassist )
            testRuntime( libraries.h2 )
            deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-6"
        }

        sourceSets {
            main {
                compileClasspath += configurations.provided
            }
        }

        manifest.mainAttributes(
                provider: 'gradle',
                'Implementation-Url': 'http://hibernate.org',
                'Implementation-Version': version,
                'Implementation-Vendor': 'Hibernate.org',
                'Implementation-Vendor-Id': 'org.hibernate'
        )

        test {
            systemProperties['hibernate.test.validatefailureexpected'] = true
            maxHeapSize = "1024m"
        }

        processTestResources.doLast( {
            copy {
                from( sourceSets.test.java.srcDirs ) {
                    include '**/*.properties'
                    include '**/*.xml'
                }
                into sourceSets.test.classesDir
            }
        } )

        assemble.doLast( { install } )
        uploadArchives.dependsOn install

        targetCompatibility = "1.6"
        sourceCompatibility = "1.6"

        ideaModule {
            // treat our "provided" configuration dependencies as "Compile" scope dependencies in IntelliJ
            scopes.COMPILE.plus.add( configurations.provided )
            // Use explicitly separate compilation output directories for Gradle and IntelliJ
            File baseDirectory = new File( subProject.buildDir, "idea/classes" )
            outputDir = new File( baseDirectory, "main" )
            testOutputDir = new File( baseDirectory, "test" )
            whenConfigured { module ->
                module.dependencies*.exported = true
            }
        }
		eclipseClasspath {
			plusConfigurations.add( configurations.provided )
		}

        // elements used to customize the generated POM used during upload
        def pomConfig = {
            url 'http://hibernate.org'
            organization {
                name 'Hibernate.org'
                url 'http://hibernate.org'
            }
            issueManagement {
                system 'jira'
                url 'http://opensource.atlassian.com/projects/hibernate/browse/HHH'
            }
            scm {
                url "http://github.com/hibernate/hibernate-core"
                connection "scm:git:http://github.com/hibernate/hibernate-core.git"
                developerConnection "scm:git:git@github.com:hibernate/hibernate-core.git"
            }
            licenses {
                license {
                    name 'GNU Lesser General Public License'
                    url 'http://www.gnu.org/licenses/lgpl-2.1.html'
                    comments 'See discussion at http://hibernate.org/356.html for more details.'
                    distribution 'repo'
                }
            }
            developers {
            }
        }

        configure(install.repositories.mavenInstaller) {
            pom.project pomConfig
        }

        uploadArchives {
            repositories.mavenDeployer {
                name = 'jbossDeployer'
                configuration = configurations.deployerJars
                pom.project pomConfig
                repository(url: "https://repository.jboss.org/nexus/service/local/staging/deploy/maven2/")
                snapshotRepository(url: "https://repository.jboss.org/nexus/content/repositories/snapshots")
            }
        }

        task sourcesJar(type: Jar, dependsOn: compileJava) {
            from sourceSets.main.allSource
            classifier = 'sources'
        }

        artifacts {
            archives sourcesJar
        }

        uploadArchives.dependsOn sourcesJar
    

		if(isStandardGroovyMavenProject) {
	       	groovy group: 'org.codehaus.groovy', name: 'groovy-all', version: '1.7.4'

            testCompile 'junit:junit:4.8.1'
            testCompile spockDependency
        }
        
        if (project.name == "grails-datastore-gorm-tck") {
          compile spockDependency
        }
    }

    if (isGormDatasource) {
      dependencies {
        testCompile project(":grails-datastore-gorm-tck")
      }
      
      // We need to test against the TCK. Gradle cannot find/run tests from jars
      // without a lot of plumbing, so here we copy the class files from the TCK
      // project into this project's test classes dir so Gradle can find the test
      // classes and run them. See grails.gorm.tests.GormDatastoreSpec for on the TCK.
      
      // helper, used below.
      def toBaseClassRelativePathWithoutExtension = { String base, String classFile ->
        if (classFile.startsWith(base)) {
          def sansClass = classFile[0 .. classFile.size() - ".class".size() - 1]
          def dollarIndex = sansClass.indexOf('$')
          def baseClass = dollarIndex > 0 ? sansClass[0..dollarIndex - 1] : sansClass
          def relative = baseClass - base - '/'
          relative
        } else {
          null
        }
      }

      test.doFirst {
        def tckClassesDir = project(":grails-datastore-gorm-tck").sourceSets.main.classesDir
        def thisProjectsTests =  // surely there is a less hardcoded way to do this
        copy {
          from tckClassesDir
          into sourceSets.test.classesDir
          include "**/*.class"
          exclude { details ->
            // Do not copy across any TCK class (or nested classes of that class)
            // If there is a corresponding source file in the particular modules 
            // test source tree. Allows a module to override a test/helper.
            
            def candidatePath = details.file.absolutePath
            def relativePath = toBaseClassRelativePathWithoutExtension(tckClassesDir.absolutePath, candidatePath)

            if (relativePath == null) {
              throw new IllegalStateException("$candidatePath does not appear to be in the TCK")
            }
            
            project.file("src/test/groovy/${relativePath}.groovy").exists()
          }
        }
      }
    }

    if(project.name.startsWith("grails-")) {
      group = "org.grails"
      archivesBaseName = "grails-datastore"
    }
    else {
      group = "org.springframework"
      archivesBaseName = 'spring-datastore'
    }

    if(isStandardGroovyMavenProject) {
      configure(install.repositories.mavenInstaller) {
          pom.whenConfigured { pom ->
            def dependency = pom.dependencies.find { dep -> dep.artifactId == 'slf4j-simple' }
            dependency?.optional = true
          }
          pom.project {
            licenses {
                license {
                    name 'The Apache Software License, Version 2.0'
                    url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    distribution 'http://github.com/grails/inconsequential'
                }
            }
          }
      }

      uploadArchives {
          description = "Does a maven deploy of archives artifacts"
          def isDav = System.getProperty("deploy.protocol") == 'dav'
          def protocol = isDav ? 'dav:' : ''
//          def releaseRepositoryUrl = "https://dav.codehaus.org/repository/grails/"
          def milestoneRepositoryUrl = isSpringProject ? 's3://maven.springframework.org/milestone' :
                                                         "${protocol}https://dav.codehaus.org/repository/grails/"
          def snapshotRepositoryUrl = isSpringProject ? 's3://maven.springframework.org/snapshot' :
                                                        "${protocol}https://dav.codehaus.org/snapshots.repository/grails/"

          // add a configuration with a classpath that includes our s3 maven deployer
          configurations { deployerJars }
          dependencies {

            deployerJars "org.springframework.build.aws:org.springframework.build.aws.maven:3.0.0.RELEASE"

            // NOTE!!!!!: Maven deployment over webdav is broken due to SHA1 checksum issues. To deploy
            // you first need to run ./gradlew -Ddeploy.protocol=dav uploadArchives
            // and then ./gradlew uploadArchives a second time to get a valid deployment

            if(isDav) {
              deployerJars "org.apache.maven.wagon:wagon-webdav-jackrabbit:1.0-beta-6"
            }
            else {
              deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-6"
            }



          }

          repositories.mavenDeployer {
              switch (releaseType) {
                  case 'RELEASE':
                    // TODO: Will need to update this when doing a non-snapshot/milestone release
//                      repository(url: releaseRepositoryUrl)
//                      description += releaseRepositoryUrl
                      break;

                  case ~/M[0-9]+/:
                      description += milestoneRepositoryUrl
                      // fall through and pick up config below

                  case 'BUILD-SNAPSHOT':
                      description += snapshotRepositoryUrl
                      def credentials
                      if(isSpringProject) {
                        credentials = [userName: project.properties.s3AccessKey,
                                       passphrase: project.properties.s3SecretAccessKey]
                      }
                      else {
                        credentials = [userName: project.properties['codehaus.username'],
                                       password: project.properties['codehaus.password']]
                      }
                      configuration = configurations.deployerJars
                      repository(url: milestoneRepositoryUrl) {
                          authentication(credentials)
                      }
                      snapshotRepository(url: snapshotRepositoryUrl) {
                          authentication(credentials)
                      }
                    break;
              }

              pom.project {
                  licenses {
                      license {
                          name 'The Apache Software License, Version 2.0'
                          url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                          distribution 'repo'
                      }
                  }
              }
          }
      }

    }


		classpath 'nl.javadude.gradle.plugins:license-gradle-plugin:0.10.0'
		classpath 'net.saliman:gradle-cobertura-plugin:1.1.2'
        classpath group: 'org.gradlefx', name: 'gradlefx', version: '0.8.1'
		classpath 'org.asciidoctor:asciidoctor-gradle-plugin:0.5.0'
		classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:0.3'
    }


        classpath 'org.gradle.api.plugins:gradle-gaelyk-plugin:0.4.1'
        classpath 'org.gradle.api.plugins:gradle-gae-plugin:0.7.6'
    }




            if (project.name != "test-testng") {
                testCompile project(':test-testng')
            }
            testCompile('org.testng:testng:5.14.6') { transitive = false }
            testCompile('com.beust:jcommander:1.5') { transitive = false }
            testCompile('org.beanshell:bsh:2.0b4') { transitive = false }
            testCompile('org.hamcrest:hamcrest-core:1.3.RC2') { transitive = false }
            testCompile('org.hamcrest:hamcrest-library:1.3.RC2') { transitive = false }
        }
    

